/*
 * stm32f1xx_i2c.c
 *
 *  Created on: Mar 4, 2021
 *      Author: Daniela
 */

#include"stm32f1xx_i2c.h"

uint16_t AHB1_Prescaler[8] = {2,4,8,16,64,128,256,512};
uint16_t APB1_Prescaler[4] = {2,4,8,16};



/* 					APIs Function Implementation 					*/

/******************************************************************
 * @func			I2C_PeriClkCtrl (I2C Peripheral Clock Control)
 * @brief			This functions enables or disables peripheral clock for the given I2C
 * @param [in]		Base Address of the I2C Peripheral
 * @param [in]		Enable/Disable Macros
 * @return			None
 * @note 			None
 */
void I2C_PeriClkCtrl(I2C_RegDef_t *pI2Cx, uint8_t EnOrDi){
	if (EnOrDi == ENABLE) {
		if (pI2Cx == I2C1) {
			I2C1_PCLK_EN();
		} else if (pI2Cx == I2C2) {
			I2C2_PCLK_EN();
		}
	}
	else
	{
		if (pI2Cx == I2C1) {
			I2C1_PCLK_DI();
		} else if (pI2Cx == I2C2) {
			I2C2_PCLK_DI();
		}
	}
}

/******************************************************************
 * @func			RCC_GetPCLKValue (RCC Get PCLK 1 Value)
 * @brief			This functions calculates the frequency of the APB1 clock
 * @param [in]		None
 * @return			Frequency of the clock
 * @note 			None
 */
uint32_t RCC_GetPCLK1Value (void){

	uint32_t pclk1, sysclk;

	uint8_t clksrc, temp, ahb1_prescaler, apb1_prescaler;

	/* System clock: Defined on the register CFGR of RCC
	 * Move the bits two positions to the right so they a in the position 0 and 1.
	 * Then mask and get the value */
	clksrc = (RCC ->CFGR >> 2) & 0x3;

	if (clksrc == 0){
		sysclk = 16000000;
	} else if (clksrc == 1){
		sysclk = 8000000;
	} else if (clksrc == 2){
		sysclk = RCC_GetPLLOutputClock();
	}

	// AHB Prescaler: Defined on register CFGR
	temp = (RCC ->CFGR >> 4) & 0xF;

	if (temp < 8){
		ahb_prescaler = 1;
	} else {
		ahb1_prescaler = AHB1_Prescaler[temp-8];
		/* Example: temp = 9 -> 1001 -> [1] -> 9-8 */
	}

	// APB1 Prescaler
	temp = (RCC ->CFGR >> 8) & 0x7;

	if (temp < 4){
		apb1_prescaler = 1;
	} else {
		apb1_prescaler = APB1_Prescaler[temp-4];
	}

	pclk1 = (sysclk/ahb1_prescaler)/apb1_prescaler;

	return pclk1;
}

// Not used in this course
uint32_t RCC_GetPLLOutputClock(void){
	return;
}

/******************************************************************
 * @func			I2C_Init (I2C Initialization)
 * @brief			This functions initializes a given I2C
 * @param [in]		Base Address of the I2C Handle
 * @return			None
 * @note 			None
 */
void I2C_Init(I2C_Handle_t *pI2CxHandle){

	uint32_t temp = 0;

	// Configuration of ACK bit
	temp |= (pI2CxHandle->I2C_Config.I2C_ACKControl << 10);
	pI2CxHandle->pI2Cx->CR1 = temp;

	// Configuration of the FREQ
	temp = 0;
	temp |= RCC_GetPCLK1Value()/ 1000000U;
	pI2CxHandle->pI2Cx->CR2 = (temp & 0x3F); // To mask the rest of the bits

	// Configuration of the slave address
	temp |= (pI2CxHandle->I2C_Config.I2C_DeviceAddress << 1);
	temp |= (1 << 14); // Bit 14 must be 1 according to the manual
	pI2CxHandle->pI2Cx->OAR1 = temp;

	// CCR calculations
	uint16_t ccr_value = 0;
	temp = 0;

	if(pI2CxHandle->I2C_Config.I2C_SCLSpeed <= I2C_CLK_SPEED_SM){
		// Standard mode
		ccr_value = RCC_GetPCLK1Value()/(2*pI2CxHandle->I2C_Config.I2C_SCLSpeed);
		temp |= (ccr_value & 0xFFF);
	} else{
		// Fast mode
	}


}

/******************************************************************
 * @func			I2C_DeInit (I2C De-initialization)
 * @brief			This functions resets a given I2C Port
 * @param [in]		Base Address of the I2C that is going to be reset
 * @return			None
 * @note 			None
 */
void I2C_DeInit(I2C_RegDef_t *pI2Cx){
	if (pI2Cx == I2C1) {
		I2C1_REG_RESET();
	} else if (pI2Cx == I2C2) {
		I2C2_REG_RESET();
	}
}

/******************************************************************
 * @func			I2C_IRQConfig (I2C IRQ Configuration)
 * @brief			This functions configures the priority in the IRQ list
 * @param [in]		IQR Number
 * @param [in]		IRQ Priority
 * @param [in]		Enable or disable
 * @return			None
 * @note 			None
 */
void I2C_IRQConfig(uint8_t IRQNumber, uint8_t EnOrDi){

	if (EnOrDi == ENABLE){
			if (IRQNumber <= 31){ // IRQ Number 0-31
				*NVIC_ISER0 |= (1<< IRQNumber); // Set ISER0
			} else if (IRQNumber > 31 && IRQNumber < 64){ // IRQ Number 32-63
				*NVIC_ISER1 |= (1<< (IRQNumber%32)); // Set ISER1
			} else if (IRQNumber >= 64 && IRQNumber < 96){ // IRQ Number 64-95
				*NVIC_ISER2 |= (1<< (IRQNumber%64)); // Set ISER2
			}
		} else {
			if (IRQNumber <= 31){ // IRQ Number 0-31
				*NVIC_ICER0 |= (1<< IRQNumber); // Set ICER0
			} else if (IRQNumber > 31 && IRQNumber < 64){ // IRQ Number 32-63
				*NVIC_ICER1 |= (1<< (IRQNumber%32)); // Set ICER1
			} else if (IRQNumber >= 64 && IRQNumber < 96){ // IRQ Number 64-95
				*NVIC_ICER2 |= (1<< (IRQNumber%64)); // Set ICER2
			}
		}
}

/******************************************************************
 * @func			I2C_IRQPriority (I2C IRQ Priority)
 * @brief			This functions process the IRQ Priority
 * @param [in]		IRQ Number
 * @param [in]		IRQ Priority
 * @return			None
 * @note 			None
 */

void I2C_IRQPriority (uint8_t IRQNumber,uint32_t IRQPriority){

	uint8_t iprx =  IRQNumber/4; // Define which IPR Register you have to use (0-59)
	uint8_t iprx_section =  IRQNumber%4; // Define the section on the IPR (0-4) * 8 bc each section is 8 bits
	uint8_t aux =  ((8* iprx_section) + (8 - NO_PR_BITS_IMPLEMENTED)); // This is the arrangement done bc the 4 first bits of each section are not implemented.

	*(NVIC_PRIO_BASEADDR + (iprx)) |= (IRQPriority <<aux);
}

/******************************************************************
 * @func			I2C_PeripheralControl (I2C Peripheral Control)
 * @brief			This functions enables/disables I2C *after* the parameters initialization
 * @param [in]		Base Address of the I2C Peripheral
 * @param [in]		Enable/Disable Macros
 * @return			None
 * @note 			None
 */
void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t EnOrDi){
	if (EnOrDi == ENABLE){
		pI2Cx->CR1 |= (1 << I2C_CR1_PE);
	} else {
		pI2Cx->CR1 &= ~(1 << I2C_CR1_PE);
	}
}
