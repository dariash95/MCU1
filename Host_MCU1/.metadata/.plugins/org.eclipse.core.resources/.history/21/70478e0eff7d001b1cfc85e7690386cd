/*
 * stm32f1xx_i2c.c
 *
 *  Created on: Mar 4, 2021
 *      Author: Daniela
 */

#include"stm32f1xx_i2c.h"


/* 					APIs Function Implementation 					*/

/******************************************************************
 * @func			I2C_PeriClkCtrl (I2C Peripheral Clock Control)
 * @brief			This functions enables or disables peripheral clock for the given I2C
 * @param [in]		Base Address of the I2C Peripheral
 * @param [in]		Enable/Disable Macros
 * @return			None
 * @note 			None
 */
void I2C_PeriClkCtrl(I2C_RegDef_t *pI2Cx, uint8_t EnOrDi){
	if (EnOrDi == ENABLE) {
		if (pI2Cx == I2C1) {
			I2C1_PCLK_EN();
		} else if (pI2Cx == I2C2) {
			I2C2_PCLK_EN();
		}
	}
	else
	{
		if (pI2Cx == I2C1) {
			I2C1_PCLK_DI();
		} else if (pI2Cx == I2C2) {
			I2C2_PCLK_DI();
		}
	}
}

/******************************************************************
 * @func			I2C_Init (I2C Initialization)
 * @brief			This functions initializes a given I2C
 * @param [in]		Base Address of the I2C Handle
 * @return			None
 * @note 			None
 */
void I2C_Init(I2C_Handle_t *pI2CxHandle){

}

/******************************************************************
 * @func			I2C_DeInit (I2C De-initialization)
 * @brief			This functions resets a given I2C Port
 * @param [in]		Base Address of the I2C that is going to be reset
 * @return			None
 * @note 			None
 */
void I2C_DeInit(I2C_RegDef_t *pI2Cx){
	if (pI2Cx == I2C1) {
		I2C1_REG_RESET();
	} else if (pI2Cx == I2C2) {
		I2C2_REG_RESET();
	}
}

/******************************************************************
 * @func			I2C_IRQConfig (I2C IRQ Configuration)
 * @brief			This functions configures the priority in the IRQ list
 * @param [in]		IQR Number
 * @param [in]		IRQ Priority
 * @param [in]		Enable or disable
 * @return			None
 * @note 			None
 */
void I2C_IRQConfig(uint8_t IRQNumber, uint8_t EnOrDi){

	if (EnOrDi == ENABLE){
			if (IRQNumber <= 31){ // IRQ Number 0-31
				*NVIC_ISER0 |= (1<< IRQNumber); // Set ISER0
			} else if (IRQNumber > 31 && IRQNumber < 64){ // IRQ Number 32-63
				*NVIC_ISER1 |= (1<< (IRQNumber%32)); // Set ISER1
			} else if (IRQNumber >= 64 && IRQNumber < 96){ // IRQ Number 64-95
				*NVIC_ISER2 |= (1<< (IRQNumber%64)); // Set ISER2
			}
		} else {
			if (IRQNumber <= 31){ // IRQ Number 0-31
				*NVIC_ICER0 |= (1<< IRQNumber); // Set ICER0
			} else if (IRQNumber > 31 && IRQNumber < 64){ // IRQ Number 32-63
				*NVIC_ICER1 |= (1<< (IRQNumber%32)); // Set ICER1
			} else if (IRQNumber >= 64 && IRQNumber < 96){ // IRQ Number 64-95
				*NVIC_ICER2 |= (1<< (IRQNumber%64)); // Set ICER2
			}
		}
}

/******************************************************************
 * @func			I2C_IRQPriority (I2C IRQ Priority)
 * @brief			This functions process the IRQ Priority
 * @param [in]		IRQ Number
 * @param [in]		IRQ Priority
 * @return			None
 * @note 			None
 */

void I2C_IRQPriority (uint8_t IRQNumber,uint32_t IRQPriority){

	uint8_t iprx =  IRQNumber/4; // Define which IPR Register you have to use (0-59)
	uint8_t iprx_section =  IRQNumber%4; // Define the section on the IPR (0-4) * 8 bc each section is 8 bits
	uint8_t aux =  ((8* iprx_section) + (8 - NO_PR_BITS_IMPLEMENTED)); // This is the arrangement done bc the 4 first bits of each section are not implemented.

	*(NVIC_PRIO_BASEADDR + (iprx)) |= (IRQPriority <<aux);
}

/******************************************************************
 * @func			I2C_PeripheralControl (I2C Peripheral Control)
 * @brief			This functions enables/disables I2C *after* the parameters initialization
 * @param [in]		Base Address of the I2C Peripheral
 * @param [in]		Enable/Disable Macros
 * @return			None
 * @note 			None
 */
void I2C_PeripheralControl(I2C_RegDef_t *pI2Cx, uint8_t EnOrDi){
	if (EnOrDi == ENABLE){
		pI2Cx->CR1 |= (1 << I2C_CR1_PE);
	} else {
		pI2Cx->CR1 &= ~(1 << I2C_CR1_PE);
	}
}
